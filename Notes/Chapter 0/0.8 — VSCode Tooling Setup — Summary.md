This assumes:

- Linux
    
- GCC 13 installed
    
- You want a clean, professional, modern C++ setup
    
- Everything consistently uses `g++-13`

---

# Build Configurations – Learn C++ (GCC 13 on Linux)

A build configuration in Visual Studio Code is defined in `.vscode/tasks.json`. VS Code does not automatically create separate Debug and Release modes. Instead, you explicitly define how the compiler is invoked.

C++ support is provided by the Microsoft C/C++ Extension.

This configuration uses GCC 13 explicitly to ensure deterministic builds and consistent IntelliSense behavior.

---

# 1. Build Configuration (`tasks.json`)

This is your **final Debug-oriented build configuration**:

```json
{
  "version": "2.0.0",
  "tasks": [
    {
      "type": "cppbuild",
      "label": "C/C++: g++-13 build active file",
      "command": "/usr/bin/g++-13",
      "args": [
        "-fdiagnostics-color=always",
        "-g",
        "${file}",
        "-o",
        "${fileDirname}/${fileBasenameNoExtension}"
      ],
      "options": {
        "cwd": "${fileDirname}"
      },
      "problemMatcher": ["$gcc"],
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "detail": "Build active file using GCC 13."
    }
  ]
}
```

### What this does

- Uses `/usr/bin/g++-13`
    
- Compiles the active `.cpp` file
    
- Outputs the executable to the same directory
    
- Generates debug symbols (`-g`)
    
- Enables colored diagnostics
    
- Sets this as the default build task
    

This is the configuration used when pressing the play button.

---

# 2. Debug Configuration (`launch.json`)

This launches the program under GDB and ensures the build runs first.

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "C/C++: g++-13 build and debug active file",
      "type": "cppdbg",
      "request": "launch",
      "program": "${fileDirname}/${fileBasenameNoExtension}",
      "args": [],
      "stopAtEntry": false,
      "cwd": "${workspaceFolder}",
      "environment": [],
      "externalConsole": false,
      "MIMode": "gdb",
      "miDebuggerPath": "/usr/bin/gdb",
      "setupCommands": [
        {
          "description": "Enable pretty-printing for gdb",
          "text": "-enable-pretty-printing",
          "ignoreFailures": true
        }
      ],
      "preLaunchTask": "C/C++: g++-13 build active file"
    }
  ]
}
```

### Key alignment points

- `MIMode` is `gdb`
    
- `miDebuggerPath` points to `/usr/bin/gdb`
    
- `preLaunchTask` matches the task label exactly
    

---

# 3. IntelliSense Configuration (`c_cpp_properties.json`)

This must match the compiler used for building.

```json
{
  "configurations": [
    {
      "name": "Linux",
      "includePath": ["${workspaceFolder}/**"],
      "defines": [],
      "compilerPath": "/usr/bin/g++-13",
      "cStandard": "c11",
      "cppStandard": "c++17",
      "intelliSenseMode": "linux-gcc-x64"
    }
  ],
  "version": 4
}
```

### Important

- `compilerPath` matches `/usr/bin/g++-13`
    
- `intelliSenseMode` matches GCC on Linux
    
- This file affects IntelliSense only — not compilation
    

---

# Release Build (Optional Extension)

If you later want an optimized build, create a second task and replace:

```
"-g"
```

with:

```
"-O2",
"-DNDEBUG"
```

Do not modify the Debug task. Keep both separate.

---

# Final State Summary

Your environment is now:

- GCC 13 used everywhere
    
- GDB configured correctly
    
- IntelliSense aligned with the compiler
    
- Debug task properly defined
    
- No mismatches between build and analysis
    

This is the complete, consistent, production-ready configuration for your chapter.