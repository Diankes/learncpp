# 0.10 — Compiler extensions — Summary

The C++ standard defines how compliant programs must behave. However, many compilers implement additional non-standard behaviors known as **compiler extensions**.

Compiler extensions allow code that is not strictly standard-compliant to compile successfully. While sometimes convenient, they introduce portability problems:

- Code may fail to compile on other compilers  
- Behavior may differ across systems  
- Beginners may accidentally learn non-standard C++

Because extensions are never required for correct C++ programs, they should be disabled when learning or writing portable code.

Best practice: disable compiler extensions so your programs remain strictly compliant with the C++ standard.

---

## What are compiler extensions?

When you compile with GCC, the compiler does not default to strict ISO C++ mode. Instead, it enables **GNU extensions** on top of the selected language standard.

For example:

- Some non-standard keywords are accepted
- Certain implicit conversions are allowed
- Extra language features may compile even though they are not part of ISO C++

Code that compiles under GNU extensions may fail on other compilers such as MSVC or Clang in strict mode.

---

## Disabling compiler extensions (GCC 13)

You are using:

- Linux  
- `g++-13`  
- The entity["software","Microsoft C/C++ Extension","vscode extension"]  

To enforce strict compliance, add the `-pedantic-errors` flag to your build task.

This tells GCC to:

- Enforce ISO rules
- Treat non-standard constructs as errors
- Prevent GNU-specific extensions from compiling silently

---

## Final `tasks.json` configuration (strict mode)

Below is the complete, correct build configuration using **g++-13** with extensions disabled.

```json
{
  "version": "2.0.0",
  "tasks": [
    {
      "type": "cppbuild",
      "label": "C/C++: g++-13 build active file",
      "command": "/usr/bin/g++-13",
      "args": [
        "-fdiagnostics-color=always",
        "-g",
        "-std=c++17",
        "-pedantic-errors",
        "${file}",
        "-o",
        "${fileDirname}/${fileBasenameNoExtension}"
      ],
      "options": {
        "cwd": "${fileDirname}"
      },
      "problemMatcher": ["$gcc"],
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "detail": "Build active file using GCC 13 (strict ISO C++ mode)."
    }
  ]
}
```

This configuration:

- Uses **g++-13 explicitly**
- Compiles using C++17
- Disables compiler extensions
- Treats non-standard code as errors

---

## Keep IntelliSense consistent

Your `c_cpp_properties.json` should match the compiler:

```json
{
  "configurations": [
    {
      "name": "Linux",
      "includePath": ["${workspaceFolder}/**"],
      "defines": [],
      "compilerPath": "/usr/bin/g++-13",
      "cStandard": "c11",
      "cppStandard": "c++17",
      "intelliSenseMode": "linux-gcc-x64"
    }
  ],
  "version": 4
}
```

This keeps the editor and compiler aligned.

---

## Why this matters

If you do not disable extensions:

- You may write non-portable code
- Your code may fail in exams or interviews
- Your programs may break on different platforms

Strict mode ensures you are learning **real C++**, not GNU-specific C++.

---

Your environment is now:

- Using GCC 13 explicitly  
- Enforcing ISO C++17  
- Rejecting compiler extensions  
- Fully portable and standards-compliant  

This is the correct final state for this chapter.