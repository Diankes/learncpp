# 1.4 — Variable assignment and initialization

In **1.3 — Introduction to objects and variables**, we learned how to define variables.

Now we’ll learn how to **put values into them**.

---

# Variable assignment

After defining a variable, we can give it a value using the `=` operator.

This is called **assignment**.

```cpp
int width;  // define variable
width = 5;  // assign value 5 to width
```

The `=` operator here is called the **assignment operator**.

It copies the value on the right-hand side into the variable on the left-hand side.  
This is called **copy-assignment**.

---

## Example

```cpp
#include <iostream>

int main()
{
    int width;   // define variable
    width = 5;   // assign 5

    std::cout << width; // prints 5

    width = 7;   // overwrite previous value

    std::cout << width; // prints 7

    return 0;
}
```

Output:

```
57
```

Important:

- A variable can hold **only one value at a time**
    
- New assignments overwrite old values
    

---

## ⚠ Common beginner mistake

Do not confuse:

- `=` → assignment
    
- `==` → equality comparison
    

```cpp
width = 5;   // assign
width == 5;  // check if equal
```

---

# Variable initialization

Assignment requires two steps:

1. Define variable
    
2. Assign value
    

Initialization combines these into **one step**.

---

## Example

```cpp
int width { 5 };
```

This:

- Defines `width`
    
- Gives it initial value `5`
    

The `{ 5 }` part is called the **initializer**.

---

## Key concept

Initialization gives a variable its **initial value at creation**.

Think: _initial-ization_

---

# Forms of initialization

There are 5 common forms.

```cpp
int a;         // default-initialization (no initializer)

int b = 5;     // copy-initialization
int c(6);      // direct-initialization

int d{7};      // direct-list-initialization (preferred)
int e{};       // value-initialization
```

Spacing differences don’t matter:

```cpp
int b=5;
int c(6);
int d{7};
```

---

# Default-initialization

```cpp
int a;
```

No initializer provided.

For many types (like `int`), this leaves the variable with an **indeterminate value** (sometimes called garbage).

This is dangerous and will be covered more in 1.6.

---

# Copy-initialization

```cpp
int width = 5;
```

Value appears after `=`.

Historically inherited from C.

Modern C++ (C++17+) makes this behave similarly to other forms in most cases.

Still common in older code.

---

# Direct-initialization

```cpp
int width(5);
```

Value appears inside parentheses.

Originally introduced for efficiency with complex types.

Less common now but still used in some cases.

---

# List-initialization (modern C++)

This uses braces `{}`.

```cpp
int width{5};     // direct-list-initialization
int height = {6}; // copy-list-initialization (rare)
```

---

## Why list-initialization?

It:

- Works consistently
    
- Is unambiguous
    
- Prevents certain bugs
    
- Is recommended in modern C++
    

---

## Key visual cue

If you see `{}`, you're list-initializing.

---

# Narrowing conversions

One major benefit of list-initialization:

It **disallows narrowing conversions**.

Example:

```cpp
int w1{4.5};  // error
```

Why?

- `4.5` is fractional
    
- `int` cannot store fractional parts
    
- List-initialization refuses to silently drop `.5`
    

Compare:

```cpp
int w2 = 4.5;  // compiles, becomes 4
int w3(4.5);   // compiles, becomes 4
```

Copy- and direct-initialization silently truncate.

List-initialization protects you.

---

Important:

This protection only applies at initialization.

```cpp
int w{5};
w = 4.5; // allowed (becomes 4)
```

---

# Value-initialization

When braces are empty:

```cpp
int width{};
```

This performs **value-initialization**.

For integers, this means:

- Zero-initialization
    
- `width` becomes `0`
    

---

## Why use `{}`?

Safer than:

```cpp
int x;  // uninitialized (dangerous)
```

Better:

```cpp
int x{};  // initialized to 0
```

---

# Modern best practice

Prefer:

- `int x{value};`
    
- `int x{};`
    

Avoid:

- Leaving variables uninitialized
    
- Mixing multiple variables on one line
    

---

# `{0}` vs `{}`

Use `{0}` when zero is meaningful:

```cpp
int x{0};
std::cout << x;
```

Use `{}` when value will immediately be replaced:

```cpp
int x{};
std::cin >> x;
```

---

# Always initialize variables

Initialize variables when you create them.

You may skip this in rare performance-critical cases, but only deliberately.

---

# Instantiation

**Instantiation** means:

- Memory allocated
    
- Initialization performed
    

The object now exists.

---

# Initializing multiple variables

Allowed:

```cpp
int a{5}, b{6};
int c{}, d{};
```

But beware this trap:

```cpp
int a, b = 5; // WRONG
```

Only `b` is initialized.

Correct:

```cpp
int a = 5, b = 5;
```

Each variable needs its own initializer.

---

## Best practice reminder

Avoid defining multiple variables on one line.

Instead:

```cpp
int a{5};
int b{6};
```

Clearer and safer.

---

# Unused variable warnings

Modern compilers warn if a variable is defined but never used.

Example:

```cpp
int main()
{
    int x{5};
    return 0;
}
```

You may see:

```
error: unused variable 'x'
```

---

## Fix options

1. Remove the variable
    
2. Use the variable
    
3. Use `[[maybe_unused]]` (C++17)
    

---

# `[[maybe_unused]]`

C++17 introduced this attribute to silence unused-variable warnings intentionally.

```cpp
[[maybe_unused]] double gravity{9.8};
```

Use this only when:

- The variable may be used in some builds
    
- You're defining shared constant values
    
- There is a legitimate reason
    

Compilers usually optimize unused variables away.

---

# Summary

## Assignment

- Happens after definition
    
- Uses `=`
    
- Overwrites previous value
    

## Initialization

- Happens at creation
    
- Preferred in modern C++
    
- Use `{}` style
    

## Preferred style

```cpp
int x{5};
int y{};
```

## Avoid

- Uninitialized variables
    
- Multiple variables per line
    
- Narrowing conversions
    

---

# Quiz recap

**Difference between initialization and assignment?**  
Initialization happens at creation.  
Assignment happens after creation.

**Preferred initialization style?**  
Direct-list-initialization (`{}`).

**Default vs value-initialization?**

- Default → no initializer → often garbage value
    
- Value → `{}` → usually zero
    

Prefer **value-initialization**.

---

Next up: what happens when variables are not initialized — and why that’s dangerous.