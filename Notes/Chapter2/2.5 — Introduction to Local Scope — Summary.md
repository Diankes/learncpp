# 2.5 — Introduction to Local Scope — Summary

---

# Local Variables

A **local variable** is a variable defined inside a function.

```cpp
int add(int x, int y)
{
    int z{ x + y }; // local variable
    return z;
}
```

Important:

- Function parameters (`x`, `y`) are also local variables.
    
- Local variables belong only to the function they are defined in.
    

---

# Local Variable Lifetime (Runtime)

**Lifetime** = how long a variable exists while the program runs.

### Creation

- Parameters are created when the function is called.
    
- Local variables are created at the point of definition.
    

### Destruction

- Local variables are destroyed at the end of the block (`}`) where they were defined.
    
- Destruction happens in reverse order of creation.
    

Example:

```cpp
int add(int x, int y)
{
    int z{ x + y };
    return z;
} // z, y, x destroyed here
```

Key idea:

> Lifetime is a runtime property.

---

# What Happens When a Variable Is Destroyed?

- The object becomes invalid.
    
- Its memory may later be reused.
    
- Using it after destruction → **undefined behavior**.
    

---

# Local Scope (Compile-Time)

**Scope** determines where a name can be used in the source code.

- Local variables have **block scope**
    
- They are usable from their definition to the end of the nearest `{ }`
    

Example:

```cpp
int main()
{
    int x{ 0 }; // x enters scope here
} // x goes out of scope here
```

Important:

- `x` is NOT visible in other functions.
    
- Calling a function does not share scope.
    

Key idea:

> Scope is compile-time.  
> Lifetime is runtime.

---

# “Out of Scope” vs “Going Out of Scope”

- **Out of scope** → identifier can’t be used in that part of code.
    
- **Going out of scope** → object reaches end of its block and is destroyed.
    

For local variables:

> Lifetime ends when it goes out of scope.

---

# Functions Are Independent

This works:

```cpp
int add(int x, int y)
{
    return x + y;
}

int main()
{
    int x{ 5 };
    int y{ 6 };

    std::cout << add(x, y);
}
```

Even though both functions use `x` and `y`, they are:

- Completely separate variables
    
- In different scopes
    
- Invisible to each other
    

Key insight:

> Local variables in one function have nothing to do with variables in another function.

This keeps functions modular and independent.

---

# Best Practice — Where to Define Variables

Modern C++ guideline:

> Define variables as close to their first use as reasonable.

Good:

```cpp
std::cin >> x;
int sum{ x + y };
```

Bad (old C-style):

```cpp
int x, y, sum; // defined too early
```

Why?

- Harder to read
    
- Harder to understand usage
    
- Forces delayed initialization
    

---

# Parameters vs Local Variables

When should you use each?

### Use a parameter when:

- The caller supplies the value.
    

### Use a local variable when:

- The function determines the value itself.
    

Wrong:

```cpp
int getValueFromUser(int val) // unnecessary parameter
```

Correct:

```cpp
int getValueFromUser()
{
    int val{};
    std::cin >> val;
    return val;
}
```

Best practice:

> Use parameters for caller-provided input.  
> Use local variables otherwise.

---

# Temporary Objects

A **temporary object** is an unnamed object created to hold a value briefly.

Example:

```cpp
std::cout << getValueFromUser() << '\n';
```

What happens?

1. `getValueFromUser()` returns a value
    
2. That value is stored in a temporary
    
3. The temporary is passed to `std::cout`
    
4. Temporary is destroyed at end of the full expression
    

Key insight:

> Returning by value creates a temporary object.

Temporary objects:

- Have no name
    
- Have no scope
    
- Are destroyed at end of the full expression
    
- Often optimized away in modern C++
    

---

# Important Behavior Example

```cpp
void doIt(int x)
{
    int y{ 4 };
    x = 3;
}
```

Calling:

```cpp
int x{ 1 };
doIt(x);
```

Result:

- `doIt` gets a copy of `x`
    
- Changing `x` inside `doIt` does NOT affect `main`’s `x`
    

Because:

> Pass-by-value creates copies.

---

# Key Takeaways

- Local variables exist only inside their function.
    
- Lifetime = creation → destruction (runtime).
    
- Scope = where identifier can be used (compile-time).
    
- Variables in different functions are independent.
    
- Define variables near first use.
    
- Use parameters when caller provides input.
    
- Return-by-value creates temporaries.
    
- Pass-by-value uses copies.
    

---

# Big Picture

Local scope is what keeps functions:

- Independent
    
- Safe
    
- Predictable
    
- Modular
    

Without local scope, programs would quickly become chaotic and fragile.