# 1.7 â€” Keywords and naming identifiers

This lesson covers:

- What **keywords** are
    
- What **identifiers** are
    
- The rules for naming identifiers
    
- Best practices for writing clear, readable names
    

---

# Keywords

C++ reserves **92 words (as of C++23)** for its own use. These are called **keywords** (or reserved words).

Each keyword has a special meaning in the language.

Examples:

```
int
return
if
while
class
const
double
for
namespace
void
```

C++20 added new keywords such as:

```
concept
requires
consteval
co_await
co_return
co_yield
```

If your compiler is not set to C++20 mode, these may not be available.

---

## Important rules about keywords

- Keywords cannot be used as identifiers.
    
- They define the structure and behavior of the language.
    
- IDEs typically highlight them.
    

Example (invalid):

```cpp
int void {};   // error: void is a keyword
```

---

## Special identifiers

C++ also defines:

```
override
final
import
module
```

These have special meaning in certain contexts but are not fully reserved like keywords.

---

# Identifiers

An **identifier** is the name of a:

- Variable
    
- Function
    
- Type
    
- Or other program entity
    

Example:

```cpp
int value {};
```

`value` is the identifier.

---

# Identifier naming rules (must follow)

1. **Cannot be a keyword**
    
2. Can only contain:
    
    - Letters
        
    - Digits
        
    - Underscore `_`
        
3. Cannot start with a digit
    
4. C++ is case-sensitive
    

Valid:

```cpp
int myValue {};
int value2 {};
int my_variable {};
```

Invalid:

```cpp
int 3value {};        // starts with digit
int my value {};      // contains space
int total-cost {};    // invalid character
int return {};        // keyword
```

---

# Naming best practices (should follow)

These are conventions, not compiler rules.

---

## 1. Start variables with lowercase

Conventional:

```cpp
int value {};
```

Unconventional:

```cpp
int Value {};
int VALUE {};
```

---

## 2. Multi-word names

Two common styles:

### snake_case

```cpp
int customer_count {};
```

### camelCase

```cpp
int customerCount {};
```

Both are acceptable. Be consistent.

---

## 3. Capitalized names

Typically used for:

- Structs
    
- Classes
    
- Enums
    
- User-defined types
    

---

## 4. Avoid leading underscores

```cpp
int _count {};  // discouraged
```

Identifiers starting with `_` are often reserved for compilers and libraries.

---

# Good naming principles

Identifiers should:

- Clearly describe what they represent
    
- Be understandable to someone new to the code
    
- Be understandable to future you
    

---

## Length guideline

Make identifier length proportional to how specific it is.

Short names are fine for:

- Temporary variables
    
- Loop counters
    
- Very small scope
    

```cpp
int i {};
```

Longer names are better for:

- Global variables
    
- Specific or important values
    

```cpp
int customerCount {};
int monstersKilled {};
```

---

## Avoid vague names

Bad:

```cpp
int data {};
int time {};
int ccount {};
```

Good:

```cpp
int customerCount {};
int minutesElapsed {};
```

---

## Avoid excessive abbreviations

Bad:

```cpp
int numCstmr {};
```

Acceptable abbreviations:

```
num
idx
cm
```

Only if common and unambiguous.

---

# Key insight

Code is read more often than it is written.

Saving time with unclear names costs more time for every future reader.

Use clear names and rely on editor auto-complete instead of shortening words unnecessarily.

---

# Using comments wisely

Instead of overly long identifiers:

```cpp
// number of characters including whitespace and punctuation
int numChars {};
```

Prefer a short clear name + comment over extremely long variable names.

---

# Summary checklist

Identifiers must:

- Not be keywords
    
- Use letters, digits, underscore only
    
- Not start with a digit
    
- Respect case sensitivity
    

Best practices:

- Start variables/functions with lowercase
    
- Use camelCase or snake_case
    
- Avoid leading underscores
    
- Choose descriptive names
    
- Match the style of the existing codebase