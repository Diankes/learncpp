# 2.10 — Introduction to the Preprocessor

---

## 1. What the Preprocessor Does

Before compilation, each `.cpp` file goes through a **preprocessing phase**.

- A program called the **preprocessor** modifies the source code _in memory_ (not the original file).
    
- It handles:
    
    - Removing comments
        
    - Ensuring proper formatting (e.g., newline at end of file)
        
    - Processing **preprocessor directives** (like `#include`, `#define`)
        

After preprocessing, the result is called a **translation unit**, which is then compiled.

The full process = **preprocessing + compiling + linking**, collectively called **translation**.

---

## 2. Preprocessor Directives

Preprocessor directives:

- Start with `#`
    
- End with a newline (not a semicolon)
    
- Are handled before compilation
    
- Do **not** follow normal C++ syntax rules
    

The compiler never sees directives — only their results.

---

## 3. `#include`

`#include` replaces itself with the contents of another file.

Example:

```cpp
#include <iostream>
```

The preprocessor literally inserts the contents of `<iostream>` into your file.

A **translation unit** = one `.cpp` file + all headers it includes (recursively).

---

## 4. `#define` and Macros

A **macro** is a text-replacement rule.

Two types:

### A) Object-like macros

**With substitution text**

```cpp
#define MY_NAME "Alex"
```

Every occurrence of `MY_NAME` becomes `"Alex"`.

Modern C++ recommendation:

- Avoid these.
    
- Prefer `constexpr`, inline variables, etc.
    

**Without substitution text**

```cpp
#define PRINT_JOE
```

This defines a flag that replaces occurrences with nothing.

These are commonly used for **conditional compilation**.

---

### B) Function-like macros

They act like functions but are unsafe and outdated.  
Prefer normal C++ functions instead.

---

## 5. Conditional Compilation

Allows code to compile only if certain macros are defined.

### `#ifdef`

Compiles code if identifier is defined.

```cpp
#ifdef PRINT_JOE
    std::cout << "Joe\n";
#endif
```

### `#ifndef`

Compiles code if identifier is NOT defined.

### Alternative syntax

```cpp
#if defined(PRINT_JOE)
#if !defined(PRINT_JOE)
```

---

## 6. `#if 0` Trick

Used to disable blocks of code:

```cpp
#if 0
    // code here is not compiled
#endif
```

Change to `#if 1` to re-enable.

Useful for temporarily disabling large sections of code, especially with nested comments.

---

## 7. Macro Substitution Rules

Important detail:

- Macros **do not expand inside most preprocessor directives**.
    
- Exception: `#if` and `#elif` often allow substitution.
    

Example:

```cpp
#define FOO 9

#ifdef FOO   // FOO is NOT replaced with 9 here
    std::cout << FOO;  // FOO IS replaced with 9 here
#endif
```

---

## 8. Scope of `#define`

Key rules:

- Processed **top to bottom**
    
- File-by-file
    
- Preprocessor does NOT understand C++ scope
    

So this:

```cpp
void foo() {
#define MY_NAME "Alex"
}
```

Is effectively the same as defining it outside the function.

Best practice:

- Place `#define` outside functions.
    

---

## 9. Macros and Multiple Files

Macros:

- Only affect the file they’re defined in
    
- Unless that file is `#include`d elsewhere
    

Example:

If `PRINT` is defined in `main.cpp`, it does NOT affect `function.cpp` unless included.

This is important for understanding:

- Header guards
    
- Multi-file projects
    

---

# Core Takeaways

- The preprocessor runs **before** compilation.
    
- It performs **text substitution**, not C++-aware transformations.
    
- `#include` copies file contents.
    
- `#define` creates macros (mostly avoid substitution macros in modern C++).
    
- Conditional compilation controls what code gets compiled.
    
- Macros are file-local unless shared via `#include`.
    

---

If you want, I can also give you a **mental model diagram** of the entire build pipeline (preprocess → compile → link) in a clean, visual way.